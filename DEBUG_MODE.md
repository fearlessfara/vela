# VTL Parser Debug Mode

The VTL parser includes a built-in debug mode that displays detailed information about how templates are parsed, including tokenization and parsing steps.

## Usage

### Using the VtlEngine class directly:

```typescript
import { VtlEngine } from './src/apigw/engine.js';

const engine = new VtlEngine(true); // Enable debug mode
const result = engine.renderTemplate({
  template: '#set($body = $input.json("$"))\n{"body": $util.toJson($body)}',
  event: { /* ... */ },
  flags: { APIGW_UTILS: 'ON', APIGW_INPUT: 'ON' }
});
```

### Using the convenience function:

```typescript
import { renderTemplate } from './src/index.js';

const result = renderTemplate({
  template: '#set($body = $input.json("$"))\n{"body": $util.toJson($body)}',
  event: { /* ... */ },
  flags: { APIGW_UTILS: 'ON', APIGW_INPUT: 'ON' }
}, true); // <-- Debug mode enabled
```

## Debug Output

When debug mode is enabled, the parser will display:

1. **Input Template**: The original template being parsed
2. **Lexer Result**: 
   - List of all tokens generated by the lexer
   - Token type, content, and position information
   - Any lexer errors
3. **Parser Result**:
   - Success/failure status
   - Detailed error information if parsing fails
   - Complete Concrete Syntax Tree (CST) if parsing succeeds

## Example Output

```
=== VTL PARSER DEBUG ===
Input: #set($body = $input.json('$'))
{
  "statusCode": 200,
  "body": $util.toJson($body)
}

Lexer Result:
Tokens:
0: SetDirective: "#set"
1: LParen: "("
2: DollarRef: "$body"
3: Assign: "="
4: DollarRef: "$input"
5: Dot: "."
6: Identifier: "json"
7: LParen: "("
8: StringLiteral: "'$'"
9: RParen: ")"
10: RParen: ")"
...

Parser Result:
Parse successful!
CST: { ... detailed syntax tree ... }
=== END DEBUG ===
```

## When to Use Debug Mode

- **Debugging parsing errors**: When templates fail to parse, debug mode shows exactly where and why
- **Understanding tokenization**: See how the lexer breaks down your template into tokens
- **Learning VTL syntax**: Understand how different VTL constructs are parsed
- **Troubleshooting complex templates**: Debug mode helps identify issues in nested expressions and directives

## Performance Note

Debug mode adds overhead due to console logging and detailed CST generation. Only enable it during development and debugging, not in production.
